# 「Clean Architecture」 読書メモ
## Spec
- タイトル: Clean Architecture 達人に学ぶソフトウェアの構造と設計
- 初版: 2018-07-27
- 著者: Robert C. Martin
- 訳者: 角 征典, 高木正弘
- 出版: ASCII DWANGO
- ISBN: 9784048930659
- サイズ: B5
- ページ数: 352ページ
- 定価: 3200円+E

（ここに表紙スキャン画像をおく）

## なぜこれを手にとったか
（3年前くらいに購入、即読破）そろそろ設計についても勉強を進め、ただプログラム書くだけマンを卒業したいと思ったから。  
Clean Codeは持っていたので、シリーズで読み応えがありそうだと考えたため。  

さいきん友人と読書会を開いてみたので記録しておこうと思い。  

## ざっくり感想
- 実際よく擦られる内容なので読んで良かった。
- これで設計の良し悪しがだいぶ直感的にも論理的にもわかるようになった感がある。
- 考え方、書き方にだいぶ癖がある上にポエマーなので100%鵜呑みにするのもおすすめしないw
- とはいえどこでも通用する考え方、常識的なことがわかるので読む価値十分あり。
- オブジェクト指向、クラスの概念に触れていないレベルではまだ早い。
- またC++のコードとUMLが読めないと理解に手間取るかも。
- シニアエンジニアとして熟成するのに最適な本の1つかと。

## 読書メモ
### まえがき
- アーキテクチャって建築に似てる。
- んじゃアーキテクチャの構造ってなんだろうね（問いかけ。ポエム全開）
- ソフトウェアアーキテクチャは目に見えないが、マシンとその周辺の性能や金、時間などに影響を受けるもんだよね。
- 開発工数やコストを減らせるアーキテクチャってどうしたらいいんだろうね、これから探っていこうぜ。

### Ⅰ部 導入
- プログラムをただ書いて動かすのはかんたん
- ソフトウェアを「正しく」するのはつらい
- 「正しい」ソフトは開発や保守のコストをわずかなものにできる
- しかし現実はクソだ。つらい。

### 1章 イントロダクション
- 「（ミクロな）設計」=「（マクロな）アーキテクチャ」
- こいつらは切り離せず、連続的でどちらも欠くことができない。
- 良いソフトの設計（アーキテクチャ）は顧客のニーズを満たすための労力を少ないものにする。
- 悪い例について
  - 開発者を増やしても生産性が上がっていかないグラフ
  - これは崩壊の兆しで、みんな必死に働いて崩壊を食い止めることしかできていない。
- 後で書き直すからOK、は嘘
  - クソコードを書くほうが結局常に遅く、非効率
  - だからクリーンなアーキテクチャが必要だよ

### 設計とアーキテクチャの違い
そんなものはない。設計というと細かい構造や意思決定のことを指し、アーキテクチャといえばそれと切り離された大枠で見ることが多い。
しかし下位レベルの詳細と上位レベルの決定の集合体が連続してシステムを定義するので結局切り離せない。

### ソフトウェアアーキテクチャの目的
求められるシステムを構築・保守するために必要なリソースを最小限にすること

### 実例
グラフなどを見せながら解説。要約すると以下の通り
- コード行が増え、人数が増え、リリースを重ねるごとに生産性が落ちている図が出てくる
- 結局の所、クリーンなコードを書くほうがだめなコードを書くより必ず速い。
- 全部放り投げて再設計しても元と同じことが起きる（崩壊する）。

## 2章 2つの価値のお話
【振る舞い】と【構造】という2つの価値について。
###  振る舞い
要件を満たすために仕事をする、これはひどい間違いである、と。(そういう事やっているから●●がそびえ立ってしまう)

### ソフトウェアとは
ソフトウェア == ソフト + ウェア
ウェアとは「プロダクト」を意味する。ソフトとはなにか。
マシンの振る舞いが簡単に変更したくないのは「ハード」ウェア。振る舞いを簡単に変更する手段のためにソフトウェアがある。当たり前だけど「ソフト」じゃないければいけない。
言い換えるとステークホルダーが機能を変更したければ簡単にできなければいけない。

### ソフトウェアのスコープと形状
開発が進むにつれ変更のコストがでかくなるのはなぜか？ステークホルダーとしては同じようなスコープの変更を伝えているが、ソフトウェアの「形状」が要件の「形状」と合わなくってくるから辛くなってくる。スパゲティになったり小さなスコープの変更なのに根こそぎ変更が必要になったりする。
したがって形状にとらわれないアーキテクチャにするべきで、ソフトウェアの変更はあくまでスコープの大きさに比例するべき。
動くことが重要なのではなく、変更し続けられることが重要。でないといつか事実上変更できなくなる日が来る（コストが重すぎるから）

### アイゼンハワーのマトリクス
あのよく出てくる「重要度」と「緊急度」のマトリクスについての話。
Biz側が「緊急で重要でないもの」と「緊急かつ重要」の判別がつかないことがある。ソフトウェア開発チームは機能の緊急性よりもアーキテクチャの重要性を強く主張する責任が求められる。これは闘争と言ってもいい。（キャディっていい会社だなあ）

# II部 プログラミングパラダイム
## 3章 パラダイムの概要
この3つである。
- 構造化プログラミング → 直接的な制御の移行に規律を課すもの
- オブジェクト指向プログラミング → 間接的な制御の移行に規律を課すもの
- 関数型プログラミング → 代入に規律を課すもの
どれもプログラマに制限を掛けている、ネガティブな意図をもって「何をすべきでない」かを定義している
このパラダイムはプログラミング黎明期に発見され、そしてそれから新しいパラダイムは出ていない。

## 4章 構造化プログラミング
Dijkstraは数学の証明を適用しユークリッドの階層を構築することを試みた過程で、gotoが分割統治を使えなくすることを発見した。
gotoを反復の制御構造にうまく使えば問題は起きず、これらのみを使用すれば証明可能な単位に再帰的に分割できる可能性が出てきた。
- 順次: 入力と出力がある → 数学的に追跡して証明した
- 選択: if, then, elseなど → これもそれぞれの経路を列挙することで証明できた
- 反復: do, whileなど → 1のときを列挙し、Nを数学的帰納法で証明し、反復の開始条件と終了条件も列挙で証明した

【ぼやき】列挙で証明した、とはなに？

この、構造化プログラミングによってモジュールが機能的に分割できる。ここから構造化分析、構造化設計といった手法が普及することになり、アーキテクチャとして機能分割がベストプラクティスであると考えられている。

### テスト
一方でDijkstraの夢であるユークリッドの階層は構築されず、今日では数学的証明ではなく反証可能性を肯定する科学的方法によって品質を担保している。
Dijkstra「テストはバグが存在しないということではなくバグが存在することを示すもの」
つまりどれだけ頑張っても正しくないことを証明できないから正しいだろうといえるということ。
しかし、証明可能なものにしかそれは適用できず、goto祭りなプログラムはいくらテストしても正しいとはみなされない。

## 5章 オブジェクト指向プログラミング
### ObjectOriented とは？
#### データと関数の組合わせ
`o.f()` のように書けるようになったと言いたいようだが、`f(o: Object)` は昔からできたではないか。

#### 現実の世界をモデル化
それだと説明が雑すぎないか。OOとはなにか説明できていないぞ。

#### カプセル化、継承、ポリモーフィズム
この3つをいい感じにサポートしたもの、という説明されがち。もうちょっと詳しく。

### カプセル化
実はC言語でもできていた。
ヘッダファイルで構造体の前方宣言と、その構造体のポインタを引数や返り値の型に使った関数のこれまた宣言だけ置いておく。
ソースに構造体の定義と関数の定義を置いておけばパーフェクトにカプセル化できている。

C++でポインタを使わないとすると、むしろ余計な部分まで書くことを強いられてしまう(ヘッダにクラス定義を全部書かないといけない)。privateキーワードが追加されたものの。これはコンパイラに対するハックである。
他の言語でもそんなもんで（※調べてないですが）OOでカプセル化されたデータを見ないようにしよう、というのは考え方としては良いが、OOのおかげでカプセル化ができるようになったとは言えない。なんなら弱体化している。

### 継承
Cの構造体内のメンバ変数は定義された順にメモリ上に並ぶ。なので手動で同じようなメモリレイアウトを含んだ「派生」クラスを定義して元のポインタにキャストすればC++の単一継承のようなことができるし、実際C++はそうやって実現している。
もっとも多重継承は困難だし、面倒くさい。アップキャストも自動でやってくれる。が「OOが全く新しい継承という概念をもたらした」とは言い難い。便利になったけど。

### ポリモーフィズム
オブジェクトを呼び出す側が意識しなくても実行時の条件に合った適切なメソッドが実行できる、しかしこれは関数ポインタを持ったオブジェクトを定義して適切な実装を呼び出すことで似たようなことを昔からやっていた。Cの標準入出力ストリームがまさにそれをやっていて、FILEポインタとかがそう。
C++ではvtableテーブルにポインタを持つようにして仮想関数の呼び出しでこれを経由するようになる。したがってこれもOOが全く新しいものを提供しているとはいえない。

### OOがもたらしたもの
このような振る舞いを実現する時、関数ポインタを弄ぶことになる。これが危険だ。
これを禁止しC言語のハックを簡単に扱えるようにする、間接的な制御の移行に規律を課すものだといえる。

#### 依存関係の逆転
通常の呼び出しのツリーを考えると制御の流れはあたかも深さ優先探索のように階層化されたコードを順番に呼び出すことになる。
しかしポリモルフィズムを活用するとこれを断ち切ることができる。
モジュールAがモジュールBの関数を呼び出すのではなく、AがBのインターフェイス経由で呼ぶようにする。こうするとBとBのインターフェイスの間で依存関係がひっくり返る。これこそOOが提供してくれるパワーだ。

```plantuml
note "典型的な呼び出し" as Note1
class ModuleB {
  f()
}
ModuleA --> ModuleB
```
```plantuml
note "依存関係の逆転" as Note1
interface InterfaceB {
}
class ModuleB {
  f()
}
ModuleA --> InterfaceB
ModuleB --|> InterfaceB
```

#### 例
これを使って、例えばUIとBusinessRulesとDatabaseという3つのコンポーネントがあったとき、BusinessRulesがUIやDBに依存しないよう設計することができる。
加えて言えばUIやDBは独立してデプロイすることができる。このようにソースコードを変更してもそのコンポーネントだけを再デプロイすればいい。これが独立デプロイ可能性だ。この状態だと別のチームが個別に開発できる。これが独立開発可能性。

【めも】マイクロサービスアーキテクチャの話に繋がりそうな予感！

## 6章 関数型プログラミング
### 導入
整数の2乗を印字するClojureプログラムの紹介。丸コピになってしまうので割愛。
代入に規律を課し、可変変数を排除したのが関数型プログラミングである。

### 不変性
関数型言語の変数は変化しない。なぜこれが嬉しいのかというと、競合状態・デッドロック・並行更新の問題の原因はすべて可変変数にあるから。
このやり方はストレージと無限のプロセッサ速度がないと現実的には厳しい。が、ある程度妥協すれば十分使い物になる。

### 可変性の分離
不変性への妥協として、可変コンポーネントと不変コンポーネントに分離するやり方がごく一般的。可変コンポーネントは状態の変更ができるため、平行性の問題が発生しうる。このためトランザクショナルメモリなどを使う（Clojureのatomについて説明あり、省略）。
できるだけ不変コンポーネントに処理を書いて、可変コンポーネントは最低限にしたい。

### イベントソーシング
状態ではなくトランザクションを保存するという考え方。状態が必要になったらすべてのトランザクションを収集して計算すればよい。
が、無限のストレージ・無限の処理能力はないのでショートカットとして例えば毎日0時の状態を保存して、そこから計算を続けるとか。
このデータストアだと削除・更新の操作が必要なくなり、CRUDびCRだけで済み、平行更新の問題も発生しない。もし十分なストレージと処理能力があればアプリケーションを完全な関数型にすることさえできる。

## 4～6章
改めて振り返ると、この3つのパラダイムは「何をすべきでない」の学びの成果といえる。やはりソフトウェアの本質は1940年代から変わっていないのだ。

# III部 設計の原則
SOLID原則について語られる。
関数やデータ構造をどうクラスに取り込むか、あるいはクラス間の相互接続をどうやるか、こういうことをまとめた原則である。
以下のようなモジュールレベルの開発を行うことを目的とする。
- 変更に強い
- 理解しやすい
- コンポーネントの基盤となり、多くのシステムで利用できる

以下の頭文字をあわせてSOLID原則と呼ばれるようになった。

- 単一責任の原則: Single Responsibility Principle
- オープン・クローズドの原則: Open-Closed Principle
- リスコフの置換原則: Liskov Substitution Principle
- インターフェイス分離の原則: Interface Segregation Principle
- 依存関係逆転の原則: Dependency Inversion Principle

【ぼやき】ここほぼ丸コピだな……

## SRP: 単一責任の原則
### よくある誤解
こうではない。 →「モジュールはたったひとつのことだけを行うべき」

正しくは、「モジュールを変更する理由はたった一つだけであるべき」
あるいはこうも言える。「各モジュールはただひとつのステークホルダー（ユーザー）に対して責務を追うべき」

### よくある例
モジュールAとBがあって、それぞれの似たような操作を一つの関数`f`に切り出すとする。
Aが`f`を変更するとBに望まない変更が入る可能性が当然ある。
AとBが同じステークホルダーに紐付いていればいいが、そうでないとBは激怒することになる。あるいは不具合に気づけないかもしれない。

### 解決策
関数を別のクラスに移動すること。データを関数から切り離し、それぞれ独立なコンポーネント化する。
こういうときにFacadeパターンが使える。

この法則自体は関数やクラスのレベルでの原則だが、コンポーネントレベルではCCPと呼ばれたり、アーキテクチャレベルで「変更の軸」と呼ばれたりしているらしい。（まだ読めてない！！）

## OCP: オープン・クローズドの原則
「ソフトウェアの構成要素は拡張に対しては開いていて、修正に対して閉じていなければならない」
言い換えれば
「ソフトウェアの振る舞いは既存の成果物を変更せずに拡張できるようにすべき」

### コンポーネントのレベルで考えてみる
AがBの変更から保護される（影響を受けずに済む）ためには、BからAに依存させること。
依存の方向をコントロールするためにはインターフェイスを挟めばよい。
各コンポーネントの優先順位の階層構造が決まれば依存関係も決められる。
→ DDDのレイヤ化アーキテクチャに通づる物を感じる！

## LSP: リスコフの置換原則
リスコフさんは派生型について以下のように定義したと。「S型のオブジェクトo1の各々に対応するT型のオブジェクトo2が存在し、Tを使って定義されたプログラムPに対してo2の代わりにo1を使ってもPの振る舞いが変わらない時、SはTの派生型であると言える」

### 正方形・長方形問題
SquareはRectangleの適切な派生型とはいいがたい。Squareは幅を同時に変えなければいけないから。
使う側でif文を書くかしてRectangleにSquareが入っているときは同時に幅を変えるよう実装するしかないが、そうすると使う側がこれらの図形の型に依存してしまう。

### アーキテクチャの観点から
文章中ではRESTfulAPIを例にとって説明していた。
その例で行くと、あるサービスだけ微妙に違うURIを採用していたらどうなるか、どんどんif文が追加されてしまうよね、という内容。

まとめると、置換可能性に違反してしまうとどんどんシステムのアーキテクチャに「特別な仕組み」が追加されてしまう。

## ISP: インターフェイス分離の原則
プログラミング言語にもよるがモジュールABがあったとき、AがBに依存していたらAに本来関係ない変更がBに入った場合でも、Aも一緒にリビルドする必要がある。
コレを防ぐためにAがインターフェイスを介してBを使えばよい……と考えると、それは言語選びの問題じゃないかと思える。

が、アーキテクチャの観点からも「必要ないもの」を含めたものに依存させるのはやめようということが書いてある。

## DIP: 依存関係逆転の原則
ソースコードの依存関係が具象ではなく抽象だけを参照しているのがもっとも柔軟なシステムだよねということを言いたいのだが、現実的には厳しい。

### 現実的に
例えばOS周りのコードが早々変わることはない（仮にそれが具象だったとしても）。
まずいのは変化しやすい具象に依存すること。

- 変化しやすい具象クラスを参照しない (Abstract Factoryパターンを活用する）
- 変化しやすい具象クラスを継承しない
- 具象関数をオーバーライドしない（結局ソースコードに依存ことになり、オーバーライドで依存関係は外せない）
- 変化しやすい具象を名指しで参照しない（それはそう）

AbstractFactoryパターンの説明があるが、それのまとめは省略する。
DIPを満たさない具象コンポーネントを完全に取り除くことはできないが、少数にとどめてそれを他と分離することはできるし、そうするべきである。

# IV部 コンポーネント
システムの一部としてデプロイできる最小単位

## 12章 コンポーネント
### 歴史的な話
ごく初期のアセンブラではライブラリはソースコードとして配布され、ビルドしていた
が、コンパイル済みのコードをロードすればいいではないかと思いついた。
しかしそのコードをメモリ上のどこに配置するかが問題となり、リンクローダが発明された。
そのうちリンクローダが外部参照を解決する処理の主sが問題になり、リンカとローダが分離された。
ともあれ、こうしてコンポーネントプラグインアーキテクチャを手に入れることができた（なるほど？）

## 13章 コンポーネントの凝集性
- 再利用・リリース等価の原則（REP）  
    コンポーネントを再利用するならそのリリース単位でやる。つまり、再利用できない単位でリリースしてはいけないとも言える。 コンポーネントは一貫した目的のためにモジュールを集めなければならない。  
    クラス・モジュールが1つのコンポーネントとしてまとめてリリース可能（じゃないなら「合理的」じゃない）。
- 閉鎖性共通の原則（CCP）  
    単一責任の法則をコンポーネントのレベルで言い換えたもの。  
    同じタイミングで変更される事が多いクラスはコンポーネント内でまとめておきたい。
- 全再利用の原則（CRP）  
    一緒に用いられることが多いクラスは同じコンポーネントにまとめておきたいが、  
    実際に使わないものにまで依存させないようにもするべき。  
    これはインターフェイス分離の原則をコンポーネントのレベルで言い換えたもの。

#### これら3つの原則の関係
- 再利用・リリース等価の原則（再利用のためのグループ化）
- 閉鎖性共通の原則（保守性のためのグループ化）
- 全再利用の原則（不要なリリースを減らすための分割）

これらは相反する性質も持つため、バランスが重要
通常、システムの立ち上げ期は再利用性を犠牲にしがち。で、それはおそらく正しくて、フェーズにあった設計を選択し続けることがとても重要。

[Qiitaも参考になる] (https://qiita.com/NagaokaKenichi/items/65c149ba92580fce5be2#:~:text=%E5%86%8D%E5%88%A9%E7%94%A8%E3%83%BB%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9%E7%AD%89%E4%BE%A1%E3%81%AE,%E7%AD%89%E4%BE%A1%E3%81%AB%E3%81%AA%E3%82%8B%E3%80%8D%E3%81%A8%E3%81%84%E3%81%86%E5%8E%9F%E5%89%87%E3%80%82)

## 14章 コンポーネントの結合
当たり前だが、コンポーネントの依存構造に循環依存があってはいけない。
コンポーネント図は有向グラフ構造になっている。これに循環関係がないことは「有向非巡回グラフ」と呼ばれる。
依存関係をたどるならグラフを逆向きにたどれば良い（それはそう）

もし循環依存になりそうなときは以下の手段が取れる

- 依存関係逆転の原則を適用する
- AとBの両方が依存するクラスを新しいコンポーネントに移動する

これも当たり前だが、トップダウンで依存関係をメンテするのは無理だし、常に変化するもの。

### 安定依存の法則
安定度の高い方向に依存させること。
変動を想定したコンポーネントが、変更しづらいコンポーネントから依存されてはいけない。
変更しづらさは伝染する。

### 安定度とは
コンポーネントA,B,CがXに依存しているとき、Xを変更しない理由が少なくとも3つはある。このとき、Xは3つのコンポーネントに対して「責務を負っている」といえる。
逆にXは他のコンポーネントに依存していないとすると外部要因で変更が必要にはならない。これを「独立コンポーネント」という。

コンポーネントYがD,E,Fに依存しているとすると、Yに依存しているコンポーネントは一つもなく、これは何も責務を負わないが、3つの外部要因によって変更しなければいけなくなる可能性がある。こういうコンポーネントを「従属コンポーネント」という。

#### 安定度の計測
- fan-in: 依存の入力数
- fan-out: 依存の出力数
- Instability: 不安定さ = fan-out / ( fan-in + fan-out )  
    I==0が最も安定していて、I==1が最も不安定

すべてのコンポーネントが安定度が高い必要はない（むしろ手がつけられない）
意図的に変更しやすいコンポーネントをおきつつ、そうでないコンポーネントに依存しそうになったら依存関係逆転の原則を適用させれば良い。

### 安定度・抽象度等価の原則
コンポーネントの抽象度は安定度と同程度でなければならない
言い換えると、安定度の低いコンポーネントは具体的で、変更しやすくなるのが望ましい。
抽象度の高くなる方向に依存するべきだ。

### 抽象度の計測
- Nc: コンポーネント内のクラスの総数
- Na: コンポーネント内の抽象クラスとインターフェイスの総数
- A: 抽象度 = Na / Nc  
    A==0だとそのコンポーネントに抽象クラスやインターフェイスが一切含まれない  
    A==1だとそのコンポーネントには抽象クラスやインターフェイスしか含まれない。  

#### プロット
座標平面の縦軸にA（抽象度）、横軸にI（不安定さ）を置いたとき、  
- (0,0) 近辺は「苦痛ゾーン」  
    安定度が最高で抽象度が低い。拡張しづらく変更も難しい。  
    DBスキーマはここに入りがち。あるいは言語のライブラリ（Stringなど）    
- (1,1) 近辺は「無駄ゾーン」  
    最大限に抽象化されているのに依存するコンポーネントがないということ。  
    実装が一つもないまま放置されている抽象クラスとか。  
- (1,0)~(0,1)をつないだ主系列ゾーン  
    ここが程よいよね！
    ということで、Distanceを考えてみる。  
    `D = | A + I - 1 |`  
    これが0付近でないものは怪しいということにする。  
    例えばだが標準偏差Z=1を超えるものはその原因を調べる価値がありそう。  

この指標は絶対ではないが、それなりに役立つのではないか、とまとめている。
